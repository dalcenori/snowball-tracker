<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Autopilot Bills + Snowball Tracker (V3.2)</title>
  <meta name="theme-color" content="#0b0f19" />
  <style>
    :root{
      --bg:#0b0f19; --card:#121a2a; --muted:#a8b3cf; --text:#eef2ff;
      --accent:#7c5cff; --good:#33d17a; --warn:#ffb020; --bad:#ff4d6d;
      --line:#22304d;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 20% 0%, #1a2450 0%, var(--bg) 50%);
      color:var(--text);
    }
    header{
      padding:18px 16px 10px;
      position:sticky; top:0; backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,15,25,.92), rgba(11,15,25,.55));
      border-bottom:1px solid rgba(34,48,77,.55);
      z-index:10;
    }
    h1{margin:0; font-size:18px; letter-spacing:.2px}
    .sub{margin:6px 0 0; color:var(--muted); font-size:12.5px}
    main{padding:14px 16px 86px; max-width:1200px; margin:0 auto}
    .grid{display:grid; gap:12px}
    @media(min-width:980px){ .grid.cols2{grid-template-columns: 1.15fr .85fr} }
    .card{
      background: linear-gradient(180deg, rgba(18,26,42,.92), rgba(18,26,42,.78));
      border:1px solid rgba(34,48,77,.7);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .spacer{flex:1}
    label{font-size:12px; color:var(--muted); display:block; margin-bottom:6px}
    input, select{
      width:100%; padding:10px 10px; border-radius:12px;
      border:1px solid rgba(34,48,77,.85); background:#0c1324; color:var(--text);
      outline:none;
    }
    input:focus, select:focus{border-color: rgba(124,92,255,.95); box-shadow:0 0 0 3px rgba(124,92,255,.2)}
    .btn{
      border:1px solid rgba(124,92,255,.9);
      background: linear-gradient(180deg, rgba(124,92,255,.95), rgba(124,92,255,.75));
      color:white; padding:10px 12px; border-radius:12px;
      cursor:pointer; font-weight:900;
    }
    .btn.sm{padding:7px 10px; font-size:12px; border-radius:10px}
    .btn.xs{padding:6px 8px; font-size:11px; border-radius:10px}
    .btn.ghost{background: transparent; border-color: rgba(34,48,77,.95); color: var(--text)}
    .btn.danger{background: linear-gradient(180deg, rgba(255,77,109,.95), rgba(255,77,109,.75)); border-color: rgba(255,77,109,.9)}
    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px; border:1px solid rgba(34,48,77,.9);
      color:var(--muted);
    }
    .pill.good{color:#b9ffe0; border-color: rgba(51,209,122,.6); background: rgba(51,209,122,.08)}
    .pill.warn{color:#ffe0a3; border-color: rgba(255,176,32,.6); background: rgba(255,176,32,.08)}
    .pill.bad{color:#ffd0d7; border-color: rgba(255,77,109,.6); background: rgba(255,77,109,.08)}
    .mono{font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1}
    .small{font-size:12px; color:var(--muted)}
    .title{font-weight:900; letter-spacing:.2px}
    .hr{height:1px; background:rgba(34,48,77,.6); margin:12px 0}
    table{width:100%; border-collapse:collapse; font-size:13px}
    th, td{padding:10px 8px; border-bottom:1px solid rgba(34,48,77,.55); vertical-align:middle}
    th{color:var(--muted); text-align:left; font-weight:650; font-size:12px}
    .right{text-align:right}
    .footerbar{
      position:fixed; left:0; right:0; bottom:0; z-index:20;
      background: linear-gradient(to top, rgba(11,15,25,.95), rgba(11,15,25,.65));
      border-top:1px solid rgba(34,48,77,.55);
      padding:10px 12px;
    }
    .footerbar .wrap{max-width:1200px; margin:0 auto; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px; color: #d9ddff; background: rgba(124,92,255,.12);
      border: 1px solid rgba(124,92,255,.35); padding: 2px 6px; border-radius: 8px;
    }
    .twoCol{display:grid; grid-template-columns:1fr; gap:10px}
    @media(min-width:620px){ .twoCol{grid-template-columns:1fr 1fr} }
    .chk{transform: scale(1.1);}
    .debtNote{font-size:11.5px; color: var(--muted); margin-top:4px; line-height:1.35}
    .simBar{
      display:none;
      margin-top:10px;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,176,32,.55);
      background: rgba(255,176,32,.07);
    }
  </style>
</head>
<body>
<header>
  <h1>Autopilot Bills + Snowball Tracker <span class="pill">V3.2</span></h1>
  <div class="sub">Unified timeline + Split bills + Quick Pay + Futurecasting + Simulation. One-time setup ‚Üí open anytime ‚Üí ‚ÄúCurrent Snapshot‚Äù.</div>
</header>

<main class="grid cols2">
  <!-- LEFT -->
  <section class="grid">
    <!-- CURRENT SNAPSHOT -->
    <div class="card">
      <div class="row">
        <div>
          <div class="title">Current Snapshot</div>
          <div class="small">Timeline-based from <b>today</b>. Quick Pay marks items paid for this month and logs it automatically.</div>
        </div>
        <div class="spacer"></div>
        <span id="healthPill" class="pill">Ready</span>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <label>Cash On Hand (right now)</label>
          <input id="cashOnHand" type="number" step="0.01" min="0" placeholder="e.g., 3000.00" />
        </div>
        <div>
          <label>Buffer Floor (don‚Äôt drop below)</label>
          <input id="bufferFloor" type="number" step="0.01" min="0" placeholder="e.g., 1500.00" />
        </div>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <label>Split % used for ‚ÄúSplit Allowed‚Äù bills (planning only)</label>
          <select id="splitPct">
            <option value="1.0">100% (no split)</option>
            <option value="0.9">90%</option>
            <option value="0.8">80%</option>
            <option value="0.7">70%</option>
            <option value="0.6">60%</option>
            <option value="0.5">50% (default)</option>
          </select>
          <div class="small">This affects <b>Committed before next payday</b> + <b>Safe-to-spend</b>, not your actual bill amount.</div>
        </div>
        <div>
          <label>Futurecasting Horizon</label>
          <select id="horizon">
            <option value="0">Current (to End of Month)</option>
            <option value="1">+1 month</option>
            <option value="3">+3 months</option>
            <option value="6">+6 months</option>
          </select>
          <div class="small">Read-only projection. Does NOT change your saved balances.</div>
        </div>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <div class="small">Safe-to-Spend NOW</div>
          <div id="safeToSpend" class="mono" style="font-size:26px; font-weight:900">$0.00</div>
          <div class="small">Cash ‚àí Buffer ‚àí (Committed before next payday)</div>
        </div>
        <div>
          <div class="small">Committed before next payday</div>
          <div id="committedBeforeNext" class="mono" style="font-size:26px; font-weight:900">$0.00</div>
          <div class="small">Uses Split % for bills marked ‚ÄúSplit Allowed‚Äù.</div>
        </div>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <div class="small">Projected Cash at Next Payday</div>
          <div id="projAtNextPay" class="mono" style="font-size:24px; font-weight:900">$0.00</div>
        </div>
        <div>
          <div class="small">Projected Cash at Horizon End</div>
          <div id="projHorizon" class="mono" style="font-size:24px; font-weight:900">$0.00</div>
        </div>
      </div>

      <div id="simBar" class="simBar">
        <div class="row">
          <div style="flex:1">
            <div class="title" style="font-size:13px">Simulation Mode</div>
            <div id="simLabel" class="small" style="margin-top:4px">‚Äî</div>
          </div>
          <button class="btn ghost sm" id="exitSimBtn">Exit Simulation</button>
        </div>
        <div class="small" style="margin-top:8px; line-height:1.5">
          Simulation is read-only. Nothing is saved unless you actually Quick Pay / add adjustments.
        </div>
      </div>

      <div class="hr"></div>

      <div class="row">
        <div style="flex:1">
          <div class="small"><span class="kbd">Autopilot</span> Next 10 events (running balance)</div>
          <div style="margin-top:10px; overflow:auto">
            <table>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Event</th>
                  <th class="right">Amount</th>
                  <th class="right">Balance</th>
                  <th class="right">Action</th>
                </tr>
              </thead>
              <tbody id="timelineTbody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="small" style="margin-top:10px">
        <span class="kbd">Quick Pay</span> logs an adjustment dated today and marks that item paid for the month (prevents double counting).
      </div>
    </div>

    <!-- INCOME + SNOWBALL SETTINGS -->
    <div class="card">
      <div class="row">
        <div class="title">Income + Snowball Settings (one-time)</div>
        <div class="spacer"></div>
        <span class="pill good">Unified</span>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <label>Pay Frequency</label>
          <select id="payFrequency">
            <option value="biweekly">Biweekly (every 14 days)</option>
            <option value="weekly">Weekly (every 7 days)</option>
            <option value="semimonthly">Semi-monthly (15th & last day)</option>
          </select>
        </div>
        <div>
          <label>Paycheck Amount (net)</label>
          <input id="paycheckAmount" type="number" step="0.01" min="0" placeholder="e.g., 1840.80" />
        </div>
        <div>
          <label>Last Payday (date)</label>
          <input id="lastPayday" type="date" />
        </div>
        <div>
          <label>Next Payday (auto)</label>
          <input id="nextPayday" type="date" disabled />
        </div>
      </div>

      <div class="hr"></div>

      <div class="twoCol">
        <div>
          <label>Snowball (monthly total)</label>
          <input id="snowballMonthly" type="number" step="0.01" min="0" placeholder="e.g., 600.00" />
          <div class="small">Autopilot allocates it across paychecks or a single day.</div>
        </div>
        <div>
          <label>Snowball Allocation</label>
          <select id="snowballAlloc">
            <option value="per_paycheck">Per Paycheck (split across paychecks)</option>
            <option value="monthly_day">Monthly on Day‚Ä¶</option>
          </select>
          <div class="small" id="allocHelp">Default: split across paychecks.</div>
        </div>
        <div id="snowballDayWrap" style="display:none">
          <label>Snowball Day of Month</label>
          <input id="snowballDay" type="number" min="1" max="31" step="1" placeholder="e.g., 20" />
        </div>
      </div>
    </div>

    <!-- BILLS -->
    <div class="card">
      <div class="row">
        <div class="title">Bills (monthly)</div>
        <div class="spacer"></div>
        <button class="btn ghost" id="addBillBtn">+ Add Bill</button>
      </div>
      <div class="small">Mark ‚ÄúSplit Allowed‚Äù if your provider lets you split/extend without disaster.</div>
      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Bill</th>
              <th class="right">Amount</th>
              <th class="right">Due Day</th>
              <th class="right">Split?</th>
              <th class="right">Action</th>
            </tr>
          </thead>
          <tbody id="billsTbody"></tbody>
        </table>
      </div>
    </div>

    <!-- DEBTS -->
    <div class="card">
      <div class="row">
        <div class="title">Debts (minimums + snowball target)</div>
        <div class="spacer"></div>
        <button class="btn" id="addDebtBtn">+ Add Debt</button>
      </div>

      <div class="twoCol" style="margin-top:10px">
        <div>
          <label>Target Strategy</label>
          <select id="strategy">
            <option value="snowball">Snowball (smallest balance)</option>
            <option value="avalanche">Avalanche (highest APR)</option>
            <option value="manual">Manual (choose)</option>
          </select>
        </div>
        <div>
          <label>Manual Target (if Manual)</label>
          <select id="manualTarget"></select>
        </div>
      </div>

      <div class="small" style="margin-top:8px">Interest/principal is estimated monthly: balance √ó APR √∑ 12. (Good enough for decision-making.)</div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Debt</th>
              <th class="right">Balance</th>
              <th class="right">APR</th>
              <th class="right">Min</th>
              <th class="right">Due</th>
              <th class="right">Paid Off</th>
              <th class="right">Action</th>
            </tr>
          </thead>
          <tbody id="debtsTbody"></tbody>
        </table>
      </div>

      <div id="payoffBox" class="small" style="margin-top:12px"></div>
      <div id="projPayoffBox" class="small" style="margin-top:8px"></div>
    </div>

    <!-- QUICK ADJUSTMENTS -->
    <div class="card">
      <div class="row">
        <div class="title">Adjustments (one-offs)</div>
        <div class="spacer"></div>
        <button class="btn ghost" id="addAdjBtn">+ Add Adjustment</button>
      </div>
      <div class="small">Reality log: surprise bill, extra payment, refund, paid early, etc.</div>

      <div style="margin-top:10px; overflow:auto">
        <table>
          <thead>
            <tr>
              <th>Date</th>
              <th>Note</th>
              <th class="right">Amount</th>
              <th class="right">Action</th>
            </tr>
          </thead>
          <tbody id="adjTbody"></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- RIGHT -->
  <aside class="grid">
    <div class="card">
      <div class="title">Autopilot Rules (simple)</div>
      <div class="small" style="margin-top:8px; line-height:1.5">
        ‚Ä¢ You input bills/debts/income once.<br>
        ‚Ä¢ Daily, update only <b>Cash On Hand</b> (optional) and use <b>Quick Pay</b> when you pay something.<br>
        ‚Ä¢ Split Allowed bills reduce ‚ÄúCommitted before next payday‚Äù using the Split %.<br>
        ‚Ä¢ Futurecasting and Simulation are read-only.
      </div>
    </div>

    <div class="card">
      <div class="title">Quick Actions</div>
      <div class="row" style="margin-top:10px">
        <button class="btn ghost" id="exportBtn">Export JSON</button>
        <button class="btn ghost" id="importBtn">Import JSON</button>
        <button class="btn ghost" id="createLinkBtn">Create Link</button>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div>
      <input id="fileInput" type="file" accept="application/json" style="display:none" />

      <div id="linkBox" style="display:none; margin-top:10px">
        <label>Transfer Link (open on another device)</label>
        <input id="transferLink" type="text" readonly />
        <div class="small" style="margin-top:6px">Tip: tap and hold to copy (or it will try to copy automatically).</div>
      </div>

      <div class="small" style="margin-top:10px">Export = backup/move device. Import restores.</div>
    </div>

    <div class="card">
      <div class="title">NFC Use</div>
      <div class="small" style="margin-top:8px; line-height:1.5">
        Write your GitHub Pages URL onto an NFC tag.
        <br><span class="kbd">Privacy</span> Everything saves on-device (localStorage). No bank logins.
      </div>
    </div>
  </aside>
</main>

<div class="footerbar">
  <div class="wrap">
    <span class="pill good">Split Bills</span>
    <span class="pill">Quick Pay</span>
    <span class="pill warn">Local-only</span>
    <div class="spacer"></div>
    <span class="small">V3.2 ‚Äî ‚ÄúOpen it, see the future, decide.‚Äù</span>
  </div>
</div>

<script>
  // ---------- Utils ----------
  const $ = (id) => document.getElementById(id);
  const money = (n) => (Number(n||0)).toLocaleString(undefined, {style:"currency", currency:"USD"});
  const clamp = (v) => Number.isFinite(v) ? v : 0;

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }
  function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

  // Dates (local noon avoids DST edge weirdness)
  function todayNoon(){
    const d = new Date();
    d.setHours(12,0,0,0);
    return d;
  }
  function parseDateInput(v){
    if(!v) return null;
    const [y,m,d] = v.split("-").map(Number);
    if(!y||!m||!d) return null;
    return new Date(y, m-1, d, 12,0,0,0);
  }
  function fmtDateInput(d){
    if(!(d instanceof Date)) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }
  function addDays(d, days){
    const x = new Date(d.getTime());
    x.setDate(x.getDate()+days);
    return x;
  }
  function addMonths(d, months){
    const x = new Date(d.getTime());
    const day = x.getDate();
    x.setDate(1);
    x.setMonth(x.getMonth()+months);
    const max = new Date(x.getFullYear(), x.getMonth()+1, 0).getDate();
    x.setDate(Math.min(day, max));
    x.setHours(12,0,0,0);
    return x;
  }
  function endOfMonth(d){
    return new Date(d.getFullYear(), d.getMonth()+1, 0, 12,0,0,0);
  }

  // ---------- Storage ----------
  const KEY = "autopilot_snowball_v3_2";
  const defaultState = {
    meta:{
      cashOnHand:0,
      bufferFloor:0,
      splitPct:0.5,
      payFrequency:"biweekly",
      paycheckAmount:0,
      lastPayday:"",
      snowballMonthly:0,
      snowballAlloc:"per_paycheck",
      snowballDay:20,
      strategy:"snowball",
      manualTargetId:null,
      horizonMonths:0
    },
    bills:[], // {id,name,amount,dueDay,splitAllowed}
    debts:[], // {id,name,balance,apr,min,dueDay,paidOff}
    adjustments:[], // {id,date,note,amount}
    paidCycles:{} // map cycleKey -> true (prevents double-counting after Quick Pay)
  };

  // ---- Simulation (NOT SAVED) ----
  const sim = {
    active: false,
    mode: null, // "payoff_now" | "extra_monthly"
    debtId: null,
    extraMonthly: 0
  };

  // ---- Link Transfer helpers ----
  function encodeTransfer(data){
    return btoa(unescape(encodeURIComponent(JSON.stringify(data))));
  }
  function decodeTransfer(str){
    return JSON.parse(decodeURIComponent(escape(atob(str))));
  }

  let state = loadState();

  // ---- Auto-restore from link ----
  (function(){
    if(location.hash && location.hash.startsWith("#t=")){
      try{
        const incoming = decodeTransfer(location.hash.slice(3));
        state = {
          meta:{...defaultState.meta, ...(incoming.meta||{})},
          bills:Array.isArray(incoming.bills)?incoming.bills:[],
          debts:Array.isArray(incoming.debts)?incoming.debts:[],
          adjustments:Array.isArray(incoming.adjustments)?incoming.adjustments:[],
          paidCycles: (incoming.paidCycles && typeof incoming.paidCycles==="object") ? incoming.paidCycles : {}
        };
        saveState();
        history.replaceState(null, "", location.pathname + location.search);
      } catch(e){
        alert("Transfer link invalid or corrupted.");
        history.replaceState(null, "", location.pathname + location.search);
      }
    }
  })();

  function loadState(){
    try{
      const raw = localStorage.getItem(KEY);
      if(!raw) return structuredClone(defaultState);
      const p = JSON.parse(raw);
      return {
        meta:{...defaultState.meta, ...(p.meta||{})},
        bills:Array.isArray(p.bills)?p.bills:[],
        debts:Array.isArray(p.debts)?p.debts:[],
        adjustments:Array.isArray(p.adjustments)?p.adjustments:[],
        paidCycles: (p.paidCycles && typeof p.paidCycles==="object") ? p.paidCycles : {}
      };
    } catch {
      return structuredClone(defaultState);
    }
  }
  function saveState(){ localStorage.setItem(KEY, JSON.stringify(state)); }

  // ---------- Paycheck schedule ----------
  function nextPaydayFrom(lastPaydayStr, freq){
    const last = parseDateInput(lastPaydayStr);
    if(!last) return null;
    const now = todayNoon();

    if(freq==="weekly"){
      let nxt = addDays(last, 7);
      while(nxt < now) nxt = addDays(nxt, 7);
      return nxt;
    }
    if(freq==="biweekly"){
      let nxt = addDays(last, 14);
      while(nxt < now) nxt = addDays(nxt, 14);
      return nxt;
    }
    // semi-monthly: 15th & last day
    const y = now.getFullYear(), m = now.getMonth();
    const fifteenth = new Date(y, m, 15, 12,0,0,0);
    const monthEnd = endOfMonth(now);
    if(now < fifteenth) return fifteenth;
    if(now < monthEnd) return monthEnd;
    const nm = new Date(y, m+1, 1, 12,0,0,0);
    return new Date(nm.getFullYear(), nm.getMonth(), 15, 12,0,0,0);
  }

  function generatePaychecks(startDate, endDate){
    const freq = state.meta.payFrequency;
    const amt = clamp(state.meta.paycheckAmount);
    const last = parseDateInput(state.meta.lastPayday);
    if(!last || amt<=0) return [];

    let next = nextPaydayFrom(state.meta.lastPayday, freq);
    if(!next) return [];

    const checks = [];
    if(freq==="semimonthly"){
      let cursor = new Date(startDate.getFullYear(), startDate.getMonth(), 1, 12,0,0,0);
      while(cursor <= endDate){
        const fif = new Date(cursor.getFullYear(), cursor.getMonth(), 15, 12,0,0,0);
        const eom = endOfMonth(cursor);
        [fif, eom].forEach(d=>{
          if(d >= startDate && d <= endDate && d >= next) checks.push({date:d, amount:amt, label:"Paycheck"});
        });
        cursor = new Date(cursor.getFullYear(), cursor.getMonth()+1, 1, 12,0,0,0);
      }
      return checks.sort((a,b)=>a.date-b.date);
    }

    let d = new Date(next.getTime());
    while(d <= endDate){
      if(d >= startDate) checks.push({date:new Date(d.getTime()), amount:amt, label:"Paycheck"});
      d = addDays(d, freq==="weekly" ? 7 : 14);
    }
    return checks;
  }

  // ---------- Targets ----------
  function chooseTargetId(snapshotDebts){
    const list = (snapshotDebts || state.debts).filter(d=>!d.paidOff);
    if(list.length===0) return null;

    if(sim.active && sim.debtId){
      const found = list.find(d=>d.id===sim.debtId);
      if(found) return found.id;
    }

    const strat = state.meta.strategy;
    if(strat==="manual" && state.meta.manualTargetId){
      const found = list.find(d=>d.id===state.meta.manualTargetId);
      if(found) return found.id;
    }
    if(strat==="avalanche"){
      list.sort((a,b)=> clamp(b.apr)-clamp(a.apr) || clamp(a.balance)-clamp(b.balance));
      return list[0].id;
    }
    list.sort((a,b)=> clamp(a.balance)-clamp(b.balance) || clamp(b.apr)-clamp(a.apr));
    return list[0].id;
  }

  function updateManualTargets(){
    const sel = $("manualTarget");
    sel.innerHTML = "";
    const debts = state.debts.filter(d=>!d.paidOff);
    const opt = document.createElement("option");
    opt.value="";
    opt.textContent = debts.length ? "Select target‚Ä¶" : "No active debts";
    sel.appendChild(opt);

    debts.forEach(d=>{
      const o = document.createElement("option");
      o.value=d.id;
      o.textContent = `${d.name} (${money(d.balance)})`;
      sel.appendChild(o);
    });
    sel.value = state.meta.manualTargetId || "";
  }

  // ---------- Paid-cycle keys ----------
  function cycleKey(type, refId, date){
    const y = date.getFullYear();
    const m = String(date.getMonth()+1).padStart(2,"0");
    return `${type}:${refId}:${y}-${m}`;
  }
  function isPaid(type, refId, date){
    return !!state.paidCycles[cycleKey(type, refId, date)];
  }
  function markPaid(type, refId, date){
    state.paidCycles[cycleKey(type, refId, date)] = true;
  }

  // ---------- Timeline event generation ----------
  function billEventDateForMonth(year, monthIndex, dueDay){
    const d = new Date(year, monthIndex, dueDay, 12,0,0,0);
    if(d.getMonth() !== monthIndex) return null;
    return d;
  }

  function generateMonthlyEvents(startDate, endDate){
    const events = [];
    let cursor = new Date(startDate.getFullYear(), startDate.getMonth(), 1, 12,0,0,0);

    while(cursor <= endDate){
      const y = cursor.getFullYear(), m = cursor.getMonth();

      // bills
      state.bills.forEach(b=>{
        const dueDay = Number(b.dueDay);
        if(!dueDay) return;
        const date = billEventDateForMonth(y,m,dueDay);
        if(!date) return;
        if(date >= startDate && date <= endDate){
          if(isPaid("bill", b.id, date)) return;
          events.push({
            date, type:"bill", refId:b.id,
            label:`Bill: ${b.name}${b.splitAllowed ? " (Split Allowed)" : ""}`,
            amount:-clamp(b.amount),
            splitAllowed: !!b.splitAllowed
          });
        }
      });

      // debt minimums
      state.debts.filter(d=>!d.paidOff).forEach(d=>{
        const dueDay = Number(d.dueDay);
        const date = dueDay ? billEventDateForMonth(y,m,dueDay) : endOfMonth(new Date(y,m,1,12,0,0,0));
        if(!date) return;
        if(date >= startDate && date <= endDate){
          if(isPaid("min", d.id, date)) return;
          events.push({
            date, type:"min", refId:d.id,
            label:`Min: ${d.name}`,
            amount:-clamp(d.min)
          });
        }
      });

      cursor = new Date(y, m+1, 1, 12,0,0,0);
    }

    // adjustments (one-offs)
    state.adjustments.forEach(a=>{
      const date = parseDateInput(a.date);
      if(!date) return;
      if(date >= startDate && date <= endDate){
        events.push({date, type:"adj", refId:a.id, label:`Adj: ${a.note}`, amount:clamp(a.amount)});
      }
    });

    // simulation: payoff now (virtual adjustment)
    if(sim.active && sim.mode==="payoff_now" && sim.debtId){
      const d = state.debts.find(x=>x.id===sim.debtId);
      if(d && !d.paidOff && clamp(d.balance)>0){
        const date = todayNoon();
        events.push({date, type:"sim", refId:"sim_payoff", label:`SIM: Payoff Now ‚Äî ${d.name}`, amount:-clamp(d.balance)});
      }
    }

    return events;
  }

  function generateSnowballEvents(startDate, endDate, paychecks){
    const events = [];
    let monthly = clamp(state.meta.snowballMonthly);
    if(sim.active && sim.mode==="extra_monthly") monthly += clamp(sim.extraMonthly);

    if(monthly <= 0) return events;

    const alloc = state.meta.snowballAlloc;

    if(alloc === "monthly_day"){
      const day = Math.max(1, Math.min(31, Number(state.meta.snowballDay)||20));
      let cursor = new Date(startDate.getFullYear(), startDate.getMonth(), 1, 12,0,0,0);
      while(cursor <= endDate){
        const date = billEventDateForMonth(cursor.getFullYear(), cursor.getMonth(), day);
        if(date && date >= startDate && date <= endDate){
          if(!isPaid("snowball", "monthly:"+fmtDateInput(date), date)){
            events.push({date, type:"snowball", refId:"monthly:"+fmtDateInput(date), label:`Snowball`, amount:-monthly});
          }
        }
        cursor = addMonths(cursor, 1);
      }
      return events;
    }

    // per paycheck split
    const checksInRange = paychecks.filter(p=>p.date >= startDate && p.date <= endDate);
    if(checksInRange.length === 0) return events;

    // split per month: distribute monthly amount across paychecks each month
    // Simple approach: split across all checks in range (good enough for planning)
    const per = monthly / checksInRange.length;

    checksInRange.forEach(p=>{
      const key = "percheck:"+fmtDateInput(p.date);
      if(isPaid("snowball", key, p.date)) return;
      events.push({date: p.date, type:"snowball", refId:key, label:`Snowball`, amount:-per});
    });

    return events;
  }

  function buildTimeline(){
    const start = todayNoon();
    const horizonMonths = Number(state.meta.horizonMonths||0);
    const end = endOfMonth(addMonths(start, horizonMonths));

    const paychecks = generatePaychecks(start, end);
    const paycheckEvents = paychecks.map(p=>({date:p.date, type:"income", refId:"income:"+fmtDateInput(p.date), label:p.label, amount:clamp(p.amount)}));

    const monthlyEvents = generateMonthlyEvents(start, end);
    const snowballEvents = generateSnowballEvents(start, end, paychecks);

    const all = [...paycheckEvents, ...monthlyEvents, ...snowballEvents]
      .sort((a,b)=> a.date - b.date || a.type.localeCompare(b.type));

    return {start, end, paychecks, events: all};
  }

  // ---------- Debt simulation engine (interest + payments) ----------
  function cloneDebtsForProjection(){
    return state.debts.map(d=>({
      id:d.id,
      name:d.name,
      balance: clamp(d.balance),
      apr: clamp(d.apr),
      min: clamp(d.min),
      dueDay: d.dueDay,
      paidOff: !!d.paidOff
    }));
  }

  function monthlyInterest(balance, apr){
    if(apr<=0 || balance<=0) return 0;
    return balance * (apr/100/12);
  }

  function monthKey(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}`; }

  function applyPaymentToDebt(debts, debtId, amount){
    // amount is positive dollars to apply
    const d = debts.find(x=>x.id===debtId);
    if(!d || d.paidOff) return {applied:0, leftover:amount};
    const before = d.balance;
    const pay = Math.min(before, amount);
    d.balance = Math.max(0, before - pay);
    if(d.balance <= 0.005) { d.balance = 0; d.paidOff = true; }
    return {applied:pay, leftover:amount - pay};
  }

  function runDebtProjection(timeline){
    const debts = cloneDebtsForProjection();
    const interestApplied = {}; // debtId -> {monthKey -> interest}
    const principalApplied = {}; // debtId -> {monthKey -> principal}
    const payoffDate = {}; // debtId -> date

    debts.forEach(d=>{
      interestApplied[d.id] = {};
      principalApplied[d.id] = {};
      payoffDate[d.id] = null;
    });

    // Track last-interest month for each debt (apply once per month when first touched in that month)
    const touchedMonth = {}; // debtId -> {monthKey:true}
    debts.forEach(d=> touchedMonth[d.id] = {});

    const events = timeline.events;

    for(const ev of events){
      // Apply monthly interest when a debt gets its first debt-related event that month
      const mk = monthKey(ev.date);

      if(ev.type==="min" && ev.amount < 0){
        const debtId = ev.refId;
        const d = debts.find(x=>x.id===debtId);
        if(d && !d.paidOff && !touchedMonth[debtId][mk]){
          const intr = monthlyInterest(d.balance, d.apr);
          if(intr>0){
            d.balance += intr;
            interestApplied[debtId][mk] = (interestApplied[debtId][mk]||0) + intr;
          }
          touchedMonth[debtId][mk] = true;
        }

        // Apply payment
        const payAmt = Math.abs(ev.amount);
        const before = d ? d.balance : 0;
        const {applied} = applyPaymentToDebt(debts, debtId, payAmt);
        const after = d ? d.balance : 0;

        const principal = Math.max(0, Math.min(before, applied));
        principalApplied[debtId][mk] = (principalApplied[debtId][mk]||0) + principal;

        if(d && d.paidOff && !payoffDate[debtId]) payoffDate[debtId] = ev.date;
      }

      if(ev.type==="snowball" && ev.amount < 0){
        // pick target based on current simulated balances
        const targetId = chooseTargetId(debts);
        let payAmt = Math.abs(ev.amount);

        // Apply interest to target this month if not touched yet
        if(targetId){
          const d = debts.find(x=>x.id===targetId);
          if(d && !d.paidOff && !touchedMonth[targetId][mk]){
            const intr = monthlyInterest(d.balance, d.apr);
            if(intr>0){
              d.balance += intr;
              interestApplied[targetId][mk] = (interestApplied[targetId][mk]||0) + intr;
            }
            touchedMonth[targetId][mk] = true;
          }

          const before = d ? d.balance : 0;
          let res = applyPaymentToDebt(debts, targetId, payAmt);
          const applied = res.applied;
          payAmt = res.leftover;

          const principal = Math.max(0, Math.min(before, applied));
          principalApplied[targetId][mk] = (principalApplied[targetId][mk]||0) + principal;

          if(d && d.paidOff && !payoffDate[targetId]) payoffDate[targetId] = ev.date;

          // If leftover exists (target paid off), cascade to next targets
          while(payAmt > 0.01){
            const nextId = chooseTargetId(debts);
            if(!nextId) break;
            const nd = debts.find(x=>x.id===nextId);
            if(nd && !nd.paidOff && !touchedMonth[nextId][mk]){
              const intr2 = monthlyInterest(nd.balance, nd.apr);
              if(intr2>0){
                nd.balance += intr2;
                interestApplied[nextId][mk] = (interestApplied[nextId][mk]||0) + intr2;
              }
              touchedMonth[nextId][mk] = true;
            }
            const before2 = nd ? nd.balance : 0;
            const res2 = applyPaymentToDebt(debts, nextId, payAmt);
            const applied2 = res2.applied;
            payAmt = res2.leftover;

            const principal2 = Math.max(0, Math.min(before2, applied2));
            principalApplied[nextId][mk] = (principalApplied[nextId][mk]||0) + principal2;

            if(nd && nd.paidOff && !payoffDate[nextId]) payoffDate[nextId] = ev.date;
          }
        }
      }

      if(ev.type==="sim" && ev.amount < 0){
        // Simulation payoff now: apply to selected debt immediately
        const d = state.debts.find(x=>x.id===sim.debtId);
        const targetId = sim.debtId;
        if(d && targetId){
          const sd = debts.find(x=>x.id===targetId);
          if(sd && !sd.paidOff){
            const before = sd.balance;
            const amt = Math.abs(ev.amount);
            const mk2 = monthKey(ev.date);
            const res = applyPaymentToDebt(debts, targetId, amt);
            const applied = res.applied;
            const principal = Math.max(0, Math.min(before, applied));
            principalApplied[targetId][mk2] = (principalApplied[targetId][mk2]||0) + principal;
            if(sd.paidOff && !payoffDate[targetId]) payoffDate[targetId] = ev.date;
          }
        }
      }
    }

    return {debts, interestApplied, principalApplied, payoffDate};
  }

  // ---------- Snapshot calculations ----------
  function computeSnapshot(){
    const tl = buildTimeline();
    const cash = clamp(state.meta.cashOnHand);
    const buffer = clamp(state.meta.bufferFloor);
    const splitPct = clamp(state.meta.splitPct);

    const nextPay = nextPaydayFrom(state.meta.lastPayday, state.meta.payFrequency);

    // committed before next payday (planning) ‚Äî uses Split % for splitAllowed bills
    let committed = 0;
    if(nextPay){
      tl.events.forEach(ev=>{
        if(ev.date <= nextPay && ev.amount < 0){
          let add = -ev.amount;
          if(ev.type==="bill" && ev.splitAllowed) add = add * splitPct;
          committed += add;
        }
      });
    }

    const safe = cash - buffer - committed;

    // Running balance (actual cashflow timeline)
    let bal = cash;
    const running = tl.events.map(ev=>{
      bal += ev.amount;
      return {...ev, balance: bal};
    });

    // Balance up to next payday date
    let balAtNextPay = cash;
    if(nextPay){
      tl.events.forEach(ev=>{
        if(ev.date <= nextPay) balAtNextPay += ev.amount;
      });
    }

    // Horizon end cash
    let balH = cash;
    tl.events.forEach(ev=>{ balH += ev.amount; });

    // Debt projection (read-only)
    const proj = runDebtProjection(tl);

    return { timeline: tl, nextPay, committed, safe, running, balAtNextPay, balH, proj };
  }

  // ---------- Interest/Principal display for current month ----------
  function currentMonthInterestPrincipal(debt){
    const bal = clamp(debt.balance);
    const apr = clamp(debt.apr);
    const min = clamp(debt.min);
    const intr = monthlyInterest(bal, apr);
    const prin = min - intr;
    return {intr, prin};
  }

  // ---------- Quick Pay ----------
  function quickPay(ev){
    const today = todayNoon();
    const dateStr = fmtDateInput(today);

    state.adjustments.push({
      id: uid(),
      date: dateStr,
      note: `Quick Paid ‚Äî ${ev.label}`,
      amount: ev.amount
    });

    markPaid(ev.type, ev.refId, ev.date);

    render();
  }

  // ---------- Payoff estimate (rough + projection) ----------
  function payoffEstimateText(){
    const active = state.debts.filter(d=>!d.paidOff);
    const monthlyExtra = clamp(state.meta.snowballMonthly);
    if(active.length===0) return "All debts marked paid off. üéâ";
    const mins = active.reduce((a,d)=> a + clamp(d.min), 0);
    const total = active.reduce((a,d)=> a + clamp(d.balance), 0);
    const pay = mins + monthlyExtra + (sim.active && sim.mode==="extra_monthly" ? clamp(sim.extraMonthly) : 0);
    if(pay <= 0) return "Add minimum payments (and optional snowball) to estimate payoff.";
    const roughMonths = Math.ceil(total / Math.max(1, pay)); // rough, ignores interest
    const years = Math.floor(roughMonths/12), rem = roughMonths%12;
    const pretty = years>0 ? `${years}y ${rem}m` : `${rem}m`;
    return `Rough payoff pace (ignores interest): <b>${pretty}</b> at ~${money(pay)}/month toward debt.`;
  }

  function projectionSummary(snap){
    const debts = snap.proj.debts;
    const active = debts.filter(d=>!d.paidOff);
    if(active.length===0) return `Projection: all debts paid off by horizon end. üéâ`;

    const total = active.reduce((a,d)=> a + clamp(d.balance), 0);

    // find earliest payoff date among those that did pay off
    const paid = Object.entries(snap.proj.payoffDate).filter(([,v])=>v instanceof Date);
    let nextPayoff = null;
    if(paid.length){
      paid.sort((a,b)=> a[1]-b[1]);
      nextPayoff = paid[0][1];
    }

    let s = `Projection: remaining debt at horizon end ‚âà <b>${money(total)}</b>.`;
    if(nextPayoff) s += ` First payoff hits around <b>${nextPayoff.toLocaleDateString()}</b>.`;
    if(sim.active) s += ` <span class="kbd">SIM</span>`;
    return s;
  }

  // ---------- Render ----------
  function render(){
    // meta inputs
    $("cashOnHand").value = state.meta.cashOnHand ?? 0;
    $("bufferFloor").value = state.meta.bufferFloor ?? 0;

    $("splitPct").value = String(state.meta.splitPct ?? 0.5);

    $("payFrequency").value = state.meta.payFrequency ?? "biweekly";
    $("paycheckAmount").value = state.meta.paycheckAmount ?? 0;
    $("lastPayday").value = state.meta.lastPayday ?? "";
    $("snowballMonthly").value = state.meta.snowballMonthly ?? 0;
    $("snowballAlloc").value = state.meta.snowballAlloc ?? "per_paycheck";
    $("snowballDay").value = state.meta.snowballDay ?? 20;

    $("strategy").value = state.meta.strategy ?? "snowball";
    updateManualTargets();

    $("horizon").value = String(state.meta.horizonMonths ?? 0);

    // toggle snowball day UI
    const alloc = state.meta.snowballAlloc;
    $("snowballDayWrap").style.display = alloc==="monthly_day" ? "block" : "none";
    $("allocHelp").textContent = alloc==="monthly_day" ? "Snowball posts on the chosen day." : "Snowball splits across paychecks inside the timeline.";

    // next payday
    const nxt = nextPaydayFrom(state.meta.lastPayday, state.meta.payFrequency);
    $("nextPayday").value = nxt ? fmtDateInput(nxt) : "";

    // snapshot
    const snap = computeSnapshot();
    $("committedBeforeNext").textContent = money(snap.committed);
    $("safeToSpend").textContent = money(snap.safe);
    $("projAtNextPay").textContent = money(snap.balAtNextPay);
    $("projHorizon").textContent = money(snap.balH);

    // simulation bar
    const sb = $("simBar");
    if(sim.active){
      sb.style.display = "block";
      let label = "";
      if(sim.mode==="payoff_now"){
        const d = state.debts.find(x=>x.id===sim.debtId);
        label = d ? `Payoff Now (virtual) ‚Äî ${d.name}` : "Payoff Now (virtual)";
      } else if(sim.mode==="extra_monthly"){
        const d = state.debts.find(x=>x.id===sim.debtId);
        label = `${money(sim.extraMonthly)}/mo extra (virtual) ‚Üí ${d ? d.name : "Selected Debt"}`;
      }
      $("simLabel").textContent = label;
    } else {
      sb.style.display = "none";
    }

    // health pill
    const hp = $("healthPill");
    const buffer = clamp(state.meta.bufferFloor);
    if(snap.safe < 0){
      hp.textContent = "Tight (reduce snowball / adjust splits)";
      hp.className = "pill warn";
    } else if(snap.balH < buffer){
      hp.textContent = "Below buffer by horizon end";
      hp.className = "pill bad";
    } else {
      hp.textContent = "Healthy";
      hp.className = "pill good";
    }

    // timeline (next 10)
    const tb = $("timelineTbody");
    tb.innerHTML = "";
    snap.running.slice(0, 10).forEach(ev=>{
      const canQuickPay = (ev.amount < 0) && (ev.type !== "adj") && (ev.type !== "sim"); // don't quick pay adj/sim
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${ev.date.toLocaleDateString()}</td>
        <td>${escapeHtml(ev.label)}</td>
        <td class="right mono">${money(ev.amount)}</td>
        <td class="right mono">${money(ev.balance)}</td>
        <td class="right">
          ${canQuickPay ? `<button class="btn sm" data-act="quickPay" data-type="${ev.type}" data-ref="${ev.refId}" data-date="${fmtDateInput(ev.date)}">Quick Pay</button>` : `<span class="small">‚Äî</span>`}
        </td>
      `;
      tb.appendChild(tr);
    });

    // bills table
    const btb = $("billsTbody");
    btb.innerHTML = "";
    state.bills.forEach(b=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(b.name||"")}</td>
        <td class="right mono">${money(b.amount)}</td>
        <td class="right mono">${escapeHtml(String(b.dueDay||""))}</td>
        <td class="right">
          <input class="chk" type="checkbox" data-act="toggleSplit" data-id="${b.id}" ${b.splitAllowed?"checked":""} />
        </td>
        <td class="right">
          <button class="btn ghost sm" data-act="editBill" data-id="${b.id}">Edit</button>
          <button class="btn danger sm" data-act="delBill" data-id="${b.id}">Del</button>
        </td>
      `;
      btb.appendChild(tr);
    });

    // debts table
    const dtb = $("debtsTbody");
    dtb.innerHTML = "";

    state.debts.forEach(d=>{
      const ip = currentMonthInterestPrincipal(d);
      const intr = ip.intr;
      const prin = ip.prin;

      const intrTxt = intr > 0 ? money(intr) : "$0.00";
      const prinTxt = money(Math.max(0, prin));
      const warn = prin < 0 ? ` ‚Ä¢ <span style="color:#ffe0a3">Min doesn‚Äôt cover interest</span>` : "";

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div>${escapeHtml(d.name||"")}</div>
          <div class="debtNote">Interest/mo: <span class="mono">${intrTxt}</span> ‚Ä¢ Principal: <span class="mono">${prinTxt}</span>${warn}</div>
        </td>
        <td class="right mono">${money(d.balance)}</td>
        <td class="right mono">${clamp(d.apr).toFixed(2)}%</td>
        <td class="right mono">${money(d.min)}</td>
        <td class="right mono">${escapeHtml(String(d.dueDay||""))}</td>
        <td class="right"><input class="chk" type="checkbox" data-act="togglePaidDebt" data-id="${d.id}" ${d.paidOff?"checked":""} /></td>
        <td class="right">
          <button class="btn ghost xs" data-act="simPayoffNow" data-id="${d.id}">Payoff Now (SIM)</button>
          <button class="btn ghost xs" data-act="simExtraMonthly" data-id="${d.id}">+$/mo (SIM)</button>
          <div style="height:6px"></div>
          <button class="btn ghost sm" data-act="editDebt" data-id="${d.id}">Edit</button>
          <button class="btn danger sm" data-act="delDebt" data-id="${d.id}">Del</button>
        </td>
      `;
      dtb.appendChild(tr);
    });

    $("payoffBox").innerHTML = payoffEstimateText();
    $("projPayoffBox").innerHTML = projectionSummary(snap);

    // adjustments
    const atb = $("adjTbody");
    atb.innerHTML = "";
    state.adjustments
      .slice()
      .sort((a,b)=> (parseDateInput(a.date)||0) - (parseDateInput(b.date)||0))
      .forEach(a=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="mono">${escapeHtml(a.date||"")}</td>
          <td>${escapeHtml(a.note||"")}</td>
          <td class="right mono">${money(a.amount)}</td>
          <td class="right">
            <button class="btn danger sm" data-act="delAdj" data-id="${a.id}">Del</button>
          </td>
        `;
        atb.appendChild(tr);
      });

    saveState();
  }

  // ---------- Add/Edit prompts ----------
  function addOrEditBill(existing){
    const name = prompt("Bill name:", existing?.name ?? "");
    if(name===null) return;
    const amount = prompt("Monthly amount:", existing?.amount ?? "");
    if(amount===null) return;
    const dueDay = prompt("Due day of month (1-31):", existing?.dueDay ?? "");
    if(dueDay===null) return;
    const splitAllowed = confirm("Split Allowed? (OK = Yes, Cancel = No)");

    const bill = {
      id: existing?.id ?? uid(),
      name: name.trim(),
      amount: Number(amount)||0,
      dueDay: dueDay.trim() ? (Number(dueDay)||"") : "",
      splitAllowed: !!splitAllowed
    };

    if(existing){
      const i = state.bills.findIndex(b=>b.id===existing.id);
      if(i>=0) state.bills[i]=bill;
    } else {
      state.bills.push(bill);
    }
    render();
  }

  function addOrEditDebt(existing){
    const name = prompt("Debt name:", existing?.name ?? "");
    if(name===null) return;
    const balance = prompt("Current balance:", existing?.balance ?? "");
    if(balance===null) return;
    const apr = prompt("APR % (0 if none):", existing?.apr ?? "");
    if(apr===null) return;
    const min = prompt("Monthly minimum payment:", existing?.min ?? "");
    if(min===null) return;
    const dueDay = prompt("Due day of month for minimum (optional):", existing?.dueDay ?? "");
    if(dueDay===null) return;

    const debt = {
      id: existing?.id ?? uid(),
      name: name.trim(),
      balance: Number(balance)||0,
      apr: Number(apr)||0,
      min: Number(min)||0,
      dueDay: dueDay.trim()? (Number(dueDay)||"") : "",
      paidOff: existing?.paidOff ?? false
    };

    if(existing){
      const i = state.debts.findIndex(d=>d.id===existing.id);
      if(i>=0) state.debts[i]=debt;
    } else {
      state.debts.push(debt);
      if(!state.meta.manualTargetId) state.meta.manualTargetId = debt.id;
    }
    render();
  }

  function addAdjustment(){
    const date = prompt("Date (YYYY-MM-DD):", fmtDateInput(todayNoon()));
    if(date===null) return;
    const note = prompt("Note:", "");
    if(note===null) return;
    const amt = prompt("Amount (positive=in, negative=out):", "");
    if(amt===null) return;

    state.adjustments.push({
      id: uid(),
      date: date.trim(),
      note: note.trim() || "Adjustment",
      amount: Number(amt)||0
    });
    render();
  }

  // ---------- Event Wiring ----------
  $("cashOnHand").addEventListener("input", e=>{ state.meta.cashOnHand = Number(e.target.value)||0; render(); });
  $("bufferFloor").addEventListener("input", e=>{ state.meta.bufferFloor = Number(e.target.value)||0; render(); });

  $("splitPct").addEventListener("change", e=>{ state.meta.splitPct = Number(e.target.value)||0.5; render(); });

  $("horizon").addEventListener("change", e=>{ state.meta.horizonMonths = Number(e.target.value)||0; render(); });

  $("payFrequency").addEventListener("change", e=>{ state.meta.payFrequency = e.target.value; render(); });
  $("paycheckAmount").addEventListener("input", e=>{ state.meta.paycheckAmount = Number(e.target.value)||0; render(); });
  $("lastPayday").addEventListener("change", e=>{ state.meta.lastPayday = e.target.value||""; render(); });

  $("snowballMonthly").addEventListener("input", e=>{ state.meta.snowballMonthly = Number(e.target.value)||0; render(); });
  $("snowballAlloc").addEventListener("change", e=>{ state.meta.snowballAlloc = e.target.value; render(); });
  $("snowballDay").addEventListener("input", e=>{ state.meta.snowballDay = Number(e.target.value)||20; render(); });

  $("strategy").addEventListener("change", e=>{ state.meta.strategy = e.target.value; render(); });
  $("manualTarget").addEventListener("change", e=>{ state.meta.manualTargetId = e.target.value || null; render(); });

  $("addBillBtn").addEventListener("click", ()=> addOrEditBill(null));
  $("addDebtBtn").addEventListener("click", ()=> addOrEditDebt(null));
  $("addAdjBtn").addEventListener("click", ()=> addAdjustment());

  $("exitSimBtn").addEventListener("click", ()=>{
    sim.active = false;
    sim.mode = null;
    sim.debtId = null;
    sim.extraMonthly = 0;
    render();
  });

  document.addEventListener("click", (e)=>{
    const btn = e.target.closest("[data-act]");
    if(!btn) return;
    const act = btn.dataset.act;

    // Quick Pay from timeline
    if(act==="quickPay"){
      const type = btn.dataset.type;
      const refId = btn.dataset.ref;
      const date = parseDateInput(btn.dataset.date);
      if(!date) return;

      const snap = computeSnapshot();
      const found = snap.running.find(ev => ev.type===type && ev.refId===refId && fmtDateInput(ev.date)===fmtDateInput(date));
      if(!found) return;

      if(!confirm(`Quick Pay now?\n\n${found.label}\n${money(found.amount)}`)) return;
      quickPay(found);
      return;
    }

    // SIM actions
    if(act==="simPayoffNow"){
      const id = btn.dataset.id;
      const d = state.debts.find(x=>x.id===id);
      if(!d || d.paidOff) return alert("That debt is already marked paid off.");
      sim.active = true;
      sim.mode = "payoff_now";
      sim.debtId = id;
      sim.extraMonthly = 0;
      render();
      return;
    }

    if(act==="simExtraMonthly"){
      const id = btn.dataset.id;
      const d = state.debts.find(x=>x.id===id);
      if(!d || d.paidOff) return alert("That debt is already marked paid off.");
      const amt = prompt("Extra monthly amount to simulate (e.g., 100):", "100");
      if(amt===null) return;
      const n = Number(amt)||0;
      if(n<=0) return alert("Enter a positive number.");
      sim.active = true;
      sim.mode = "extra_monthly";
      sim.debtId = id;
      sim.extraMonthly = n;
      render();
      return;
    }

    // bills/debts/adjustments edits
    const id = btn.dataset.id;

    if(act==="delBill"){ state.bills = state.bills.filter(b=>b.id!==id); render(); return; }
    if(act==="editBill"){ const b = state.bills.find(x=>x.id===id); if(b) addOrEditBill(b); return; }

    if(act==="delDebt"){
      state.debts = state.debts.filter(d=>d.id!==id);
      if(state.meta.manualTargetId===id) state.meta.manualTargetId=null;
      if(sim.active && sim.debtId===id){ sim.active=false; sim.mode=null; sim.debtId=null; sim.extraMonthly=0; }
      render(); return;
    }
    if(act==="editDebt"){ const d = state.debts.find(x=>x.id===id); if(d) addOrEditDebt(d); return; }

    if(act==="delAdj"){ state.adjustments = state.adjustments.filter(a=>a.id!==id); render(); return; }
  });

  document.addEventListener("change", (e)=>{
    const t = e.target;

    // toggle split on bills
    if(t && t.matches('input[type="checkbox"][data-act="toggleSplit"]')){
      const id = t.dataset.id;
      const b = state.bills.find(x=>x.id===id);
      if(b) b.splitAllowed = !!t.checked;
      render();
    }

    // toggle paid off debt
    if(t && t.matches('input[type="checkbox"][data-act="togglePaidDebt"]')){
      const id = t.dataset.id;
      const d = state.debts.find(x=>x.id===id);
      if(d) d.paidOff = !!t.checked;
      render();
    }
  });

  // Export / Import / Reset
  $("exportBtn").addEventListener("click", ()=>{
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "autopilot-tracker-v3_2-backup.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  $("importBtn").addEventListener("click", ()=> $("fileInput").click());
  $("fileInput").addEventListener("change", async (e)=>{
    const file = e.target.files?.[0];
    if(!file) return;
    try{
      const text = await file.text();
      const p = JSON.parse(text);
      state = {
        meta:{...defaultState.meta, ...(p.meta||{})},
        bills:Array.isArray(p.bills)?p.bills:[],
        debts:Array.isArray(p.debts)?p.debts:[],
        adjustments:Array.isArray(p.adjustments)?p.adjustments:[],
        paidCycles: (p.paidCycles && typeof p.paidCycles==="object") ? p.paidCycles : {}
      };
      saveState();
      render();
      alert("Import complete.");
    } catch {
      alert("Import failed. Use an exported JSON backup.");
    } finally {
      e.target.value = "";
    }
  });

  $("resetBtn").addEventListener("click", ()=>{
    if(!confirm("Reset all tracker data on this device? This cannot be undone.")) return;
    localStorage.removeItem(KEY);
    state = structuredClone(defaultState);
    sim.active=false; sim.mode=null; sim.debtId=null; sim.extraMonthly=0;
    render();
  });

  // Create Link
  $("createLinkBtn").addEventListener("click", async ()=>{
    try{
      const payload = encodeTransfer(state);
      const link = location.origin + location.pathname + location.search + "#t=" + payload;
      $("transferLink").value = link;
      $("linkBox").style.display = "block";
      $("transferLink").focus();
      $("transferLink").select();
      if(navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(link);
      }
    } catch(e){
      alert("Could not create link (state may be too large).");
    }
  });

  // Init
  render();
</script>
</body>
</html>
